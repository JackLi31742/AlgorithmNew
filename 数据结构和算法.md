# 一、线性结构和非线性结构

1、线性：数组和链表，包括数组、队列、栈、链表

2、非线性：二维数据，多维数组，广义表，图，树

# 二、线性

## 1、稀疏数组

（1）实际问题：棋盘、地图等

<img src="img\QQ截图20200516180620.png" alt="QQ截图20200516180620" style="zoom:80%;" />

（2）解决

稀疏数组的处理方法是:
【1】记录数组一共有几行几列，有多少个不同的值
【2】把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

【3】二维数组 转 稀疏数组的思路
1. ```
   1. 遍历  原始的二维数组，得到有效数据的个数 sum
   2. 根据sum 就可以创建 稀疏数组 sparseArr   int[sum + 1][3]
   3. 将二维数组的有效数据数据存入到 稀疏数组
   ```

   

稀疏数组转原始的二维数组的思路

```
1.先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]

2.在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.
```

<img src="img\QQ截图20200516180823.png" alt="QQ截图20200516180823" style="zoom:80%;" />

## 2、队列（queue）

数组、链表都可以实现

### （1） 顺序队列（数组）

因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front及 rear分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变

【1】构造器

front=-1，指向队列头部，是队列第一个数据的前一个位置

rear=-1，指向队列尾部，是最后一个数据的位置

【2】队满

rear  == maxSize - 1

【3】队空

front==rear

【4】入队

将尾指针往后移：rear++

【5】出队（获取数据）

front++

【6】peek

arr[front+1]

### （2）环形队列（数组）

1. front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素， 
   front 的初始值 = 0

2. rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定，
   rear 的初始值 = 0

3. 当队列满时，条件是  (rear  + 1) % maxSize == front 【满】

   tail=3，head=4，n=8，所以总结一下规律就是：(3+1)%8=4。多画几张队满的图，你就会发现，当队满时，(tail+1)%n=head。你有没有发现，当队列满时，图中的 tail 指向的位置实际上是没有存储数据的。所以，**循环队列会浪费一个数组的存储空间**

4.  对队列为空的条件， rear == front 空

5. 当我们这样分析， 队列中有效的数据的个数   (rear + maxSize - front) % maxSize   // rear = 1 front = 0 

6. 我们就可以在原来的队列上修改得到，一个环形队列

【1】入队

rear=(rear+1)%maxSize

【2】出队

```java
// 1. 先把 front 对应的值保留到一个临时变量
// 2. 将 front 后移, 考虑取模
// 3. 将临时保存的变量返回
int value = arr[front];
front = (front + 1) % maxSize;
```

【3】peek

arr[front]

【4】遍历

```java
for (int i = front; i < front + size() ; i++) {
			System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
}
```

<img src="img\3d81a44f8c42b3ceee55605f9aeedcec.jpg" alt="3d81a44f8c42b3ceee55605f9aeedcec" style="zoom:60%;" />





## 3、单链表（Linked List）

### （1）物理结构

![QQ截图20200516215648](img\QQ截图20200516215648.png)



### （2）增删改查

#### 【1】顺序插入（尾插）

```java
	private HeroNode head = new HeroNode(0, "", "");
	
	
	//返回头节点
	public HeroNode getHead() {
		return head;
	}

	//添加节点到单向链表
	//思路，当不考虑编号顺序时
	//1. 找到当前链表的最后节点
	//2. 将最后这个节点的next 指向 新的节点
	public void add(HeroNode heroNode) {
		
		//因为head节点不能动，因此我们需要一个辅助遍历 temp
		HeroNode temp = head;
		//遍历链表，找到最后
		while(temp.next!=null) {
			
			//如果没有找到最后, 将将temp后移
			temp = temp.next;
		}
		//当退出while循环时，temp就指向了链表的最后
		//将最后这个节点的next 指向 新的节点
		temp.next = heroNode;
	}
```

#### 【2】先查询后插入，查找到合适的之后再插入

1. 首先找到新添加的节点的位置, 是通过辅助变量(指针), 通过遍历来搞定
2. 新的节点.next = temp.next

3. 将temp.next = 新的节点

```java
public void addByOrder(HeroNode heroNode) {
		//因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置
		//因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了
		HeroNode temp = head;
		boolean flag = false; // flag标志添加的编号是否存在，默认为false
		while(temp.next != null) {
			
			if(temp.next.no > heroNode.no) { //位置找到，就在temp的后面插入
				break;
			} else if (temp.next.no == heroNode.no) {//说明希望添加的heroNode的编号已然存在
				
				flag = true; //说明编号存在
				break;
			}
			temp = temp.next; //后移，遍历当前链表
		}
		//判断flag 的值
		if(flag) { //不能添加，说明编号存在
			System.out.printf("准备插入的英雄的编号 %d 已经存在了, 不能加入\n", heroNode.no);
		} else {
			//插入到链表中, temp的后面
			heroNode.next = temp.next;
			temp.next = heroNode;
		}
	}
```



#### 【3】修改

**设置flag的思想很不错**，如果不设置flag，就需要在while循环中的temp.no == newHeroNode.no进行修改

```java
//1. 根据 newHeroNode 的 no 来修改即可
	public void update(HeroNode newHeroNode) {
		//判断是否空
		if(head.next == null) {
			System.out.println("链表为空~");
			return;
		}
		//找到需要修改的节点, 根据no编号
		//定义一个辅助变量
		HeroNode temp = head.next;
		boolean flag = false; //表示是否找到该节点
		while(true) {
			if (temp == null) {
				break; //已经遍历完链表
			}
			if(temp.no == newHeroNode.no) {
				//找到
				flag = true;
				break;
			}
			temp = temp.next;
		}
		//根据flag 判断是否找到要修改的节点
		if(flag) {
			temp.name = newHeroNode.name;
			temp.nickname = newHeroNode.nickname;
		} else { //没有找到
			System.out.printf("没有找到 编号 %d 的节点，不能修改\n", newHeroNode.no);
		}
	}
```

#### 【4】删除

temp.next = temp.next.next;

### （3）常见面试题

## 4、双链表

## （1）增删改查

#### 【1】遍历 

和 单链表一样，只是可以向前，也可以向后查找

#### 【2】添加 

(默认添加到双向链表的最后)
(1) 先找到双向链表的最后这个节点

```java
 temp.next = newHeroNode
 newHeroNode.pre = temp;
```



#### 【3】先查询再插入

```java
heroNode.next = temp.next;
temp.next.pre=heroNode;
temp.next = heroNode;
heroNode.pre=temp
```



#### 【4】修改 

思路和 原来的单向链表一样.

#### 【5】删除

(1) 因为是双向链表，因此，我们可以实现自我删除某个节点
(2) 直接找到要删除的这个节点，比如temp
	

```java
			//如果删除的是头结点，头结点的pre是null
			if(temp!=head){
                temp.pre.next = temp.next;
            }
			
			// 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针
			if (temp.next != null) {
				temp.next.pre = temp.pre;
			}
```



## 5、环形链表(约瑟夫环)

## 6、栈

### （1）应用场景

表达式求值

子程序调用

二叉树的遍历

DFS

### （2）数组和链表实现

1. 使用数组来模拟栈
2. 定义一个 top  来表示栈顶，初始化 为  -1
3. 入栈的操作，当有数据加入到栈时， top++;  stack[top] = data;
4. 出栈的操作， int value = stack[top]; top--, return value

### （3）前缀、中缀、后缀表达式

#### 【1】前缀表达式(波兰表达式)

 (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6

#### 【2】中缀

常见的运算表达式，如(3+4)×5-6，一般转成后缀表达式

#### 【3】后缀（逆波兰表达式）

(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –

### （4）常见面试题

#### 【1】基本计算器

1. 通过一个 index  值（索引），来遍历我们的表达式
2. 如果我们发现是一个数字, 就直接入数栈
3. 如果发现扫描到是一个符号,  就分如下情况
3.1 如果发现当前的符号栈为 空，就直接入栈
3.2 如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符， 就需要从数栈中pop出两个数,在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈， 如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.
4. 当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行.

5. 最后在数栈只有一个数字，就是表达式的结果

#### 【2】中缀转后缀

1) 初始化两个栈：**运算符栈s1和储存中间结果的栈s2**；
2) 从左至右扫描中缀表达式；
3) 遇到操作数时，将其压s2；
4) 遇到运算符时，比较其与s1栈顶运算符的优先级：
1.如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
2.否则，若优先级比栈顶运算符的高，也将运算符压入s1；
3.否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；
5) 遇到括号时：(1) 如果是左括号“(”，则直接压入s1(2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
6) 重复步骤2至5，直到表达式的最右边
7) 将s1中剩余的运算符依次弹出并压入s2
8)  依次弹出s2中的元素并输出，**结果的逆序即为中缀表达式对应的后缀表达式**

#### 【3】后缀表达式求值

从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果

## 7、哈希



![图片11](img\图片11.png)



<img src="img\微信截图_20200602102245.png" alt="微信截图_20200602102245" style="zoom:50%;" />

# 三、非线性

## 1、树

### （1）概念

如果该二叉树的所有叶子节点都在最后一层，并且结点总数= **2^n -1** , n 为层数，则我们称为**满二叉树**。
如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为**完全二叉树**。

### （2）遍历

#### 【1】递归

前序遍历（中左右）: 先输出父节点，再遍历左子树和右子树
中序遍历（左中右）: 先遍历左子树，再输出父节点，再遍历右子树
后序遍历（左右中）: 先遍历左子树，再遍历右子树，最后输出父节点

#### 【2】非递归（迭代）

需要用自定义的栈模拟递归时的系统栈，莫里斯遍历虽然空间复杂度降下来了，但是会修改整个二叉树的结构！

##### 前序遍历（中左右）

要想最终的顺序得到中左右，那么入栈的时候，就是右左中，可以简化，只放右节点

```java
		TreeNode cur = root;
		//第一次把root放进去，是为了好进第一个while循环，因为当节点走到树的右侧时，其实和左侧的套路一样
		stack.push(cur);
		while (!stack.isEmpty()) {
			TreeNode node = stack.pop();
			while (node != null) {
				result.add(node.val);
				if (node.right != null) {
					stack.push(node.right);
				}
				node = node.left;
			}
		}
```



##### 中序遍历（左中右）

每次都是节点的左节点入栈，所以当传入节点的右节点时，也要把这个节点的左边节点进行入栈

```java
while (cur != null || !stack.isEmpty()) {
			while (cur != null) {
				stack.push(cur);
				cur = cur.left;
			}
			TreeNode node = stack.pop();
			result.add(node.val);

			cur = node.right;
			while (cur != null) {
				stack.push(cur);
				cur = cur.left;
			}

		}
```

##### 后序遍历（左右中）

后序遍历要先从根节点一直找到左子树的最左边的节点，然后回退到根节点，这时，需要标注根节点flag=true，标明已经回退过一次，然后传入根节点的右子树，然后重复上述过程，如果栈里的节点的flag=true，那么标明左右子树都已经找到过

```java
TreeNode cur=root;
		
		Stack<Node> stack=new Stack<Node>();
		
		while(cur!=null||!stack.isEmpty()) {
			
			//一直找到左子树的最左边
			while (cur!=null) {
				Node node=new Node(cur, false);
				stack.push(node);
				cur=cur.left;
			}
			
			if (!stack.isEmpty()) {
				if (!stack.peek().flag) {
					cur=stack.peek().treeNode.right;
					//标明从左边的子树返回到了根节点
					stack.peek().flag=true;
					
				}else {
					result.add(stack.pop().treeNode.val);
					
				}
			}
			
			
		}
```

### （3）删除节点（普通二叉树）

如果删除的节点是叶子节点，则删除该节点
如果删除的节点是非叶子节点，则删除该子树.

### （4）顺序存储二叉树（堆）

从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，


<img src="img\微信截图_20200609131025.png" alt="微信截图_20200609131025" style="zoom:80%;" />

顺序存储二叉树的特点:

顺序二叉树通常只考虑完全二叉树
第n个元素的左子节点为  2 * n + 1 
第n个元素的右子节点为  2 * n + 2
第n个元素的父节点为  (n-1) / 2

n : 表示二叉树中的第几个元素(按0开始编号)

### （5）堆排序

堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。
堆是具有以下性质的**完全二叉树**：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : **没有要求结点的左孩子的值和右孩子的值的大小关系**。
每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆

**一般升序采用大顶堆，降序采用小顶堆** 

堆排序的基本思想是：
1.**将待排序序列构造成一个大顶堆**，**从最后的非叶子节点，依次从下到上**
2.此时，整个序列的最大值就是堆顶的根节点。
3.将其与末尾元素进行交换，此时末尾就为最大值。
4.然后将剩余n-1个元素重新构造成一个堆，而这个堆，只有根节点和第二层节点不满足大顶堆的条件，所以是从上到下进行调整，这样会得到n个元素的次大值。如此反复执行，便能得到一个有序序列了。

可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.意思是**最后的数组就是从小到大的**，**当然也可以是从大到小**

### （6）哈夫曼

#### 【1】哈夫曼树

给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。

赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1

树的带权路径长度：树的带权路径长度规定为**所有叶子结点的带权路径长度之和**，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。

<img src="img\微信截图_20200609193130.png" alt="微信截图_20200609193130" style="zoom:60%;" />



构成赫夫曼树的步骤：
1.从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树
2.取出根节点权值最小的两颗二叉树 
3.组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和  
4.再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复  1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树

#### 【2】赫夫曼编码

赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%～90%之间
赫夫曼码是可变字长编码(VLC)的一种

字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码， 即不能匹配到重复的编码

```
i like like like java do you like a java       // 共40个字符(包括空格)
d:1 y:1 u:1 j:2  v:2  o:2  l:4  k:4  e:4 i:5  a:5   :9  // 各个字符对应的个数
按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值
```

<img src="img\图片21.png" alt="图片21" style="zoom:80%;" />



## 2、BST（二叉搜索树、二叉排序树）

### （1）概念

对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。
特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点

### （2）中序遍历

中序遍历的结果就是从小到大排序

### （3）删除节点

【1】删除的是叶子节点，直接删除，将其父节点指针指向null

【2】删除的节点target只有一个子节点，将父节点指向target的指针指向target的子节点

【3】删除的节点target有两个子节点：有以下两种方法删除节点

[1]找到target的左子树中最大的节点，替换要删除的节点

<img src="img\删除节点-左子树替换.gif" alt="删除节点-左子树替换" style="zoom:60%;" />

[2]找到target的右子树中最小的节点，替换要删除的节点

<img src="img\删除节点-右子树替换.gif" alt="删除节点-右子树替换" style="zoom:50%;" />

## 3、AVL树

### （1）概念

平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高

具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用**实现方法**有红黑树、AVL、替罪羊树、Treap、伸展树等

### （2）旋转

【1】左旋转：降低右子树的高度

```java
当(节点4的右子树的高度)-(节点4的左子树的高度)>1时，需要降低右子树的高度，进行左旋转
[1]创建一个新的节点newNode，newNode.value=4
[2]newNode.left=4.left
[3]newNode.right=4.right.left
[4]4.value=4.right.value
[5]4.left=newNode
[6]4.right=4.right.right
```

<img src="img\微信截图_20200722180725.png" alt="微信截图_20200722180725" style="zoom:50%;" />

【2】右旋转

```java
当(节点10的左子树的高度)-(节点10的右子树的高度)>1时，需要降低左子树的高度，进行右旋转
[1]创建一个新的节点newNode，newNode.value=10
[2]newNode.left=10.left.right
[3]newNOde.right=10.right.right
[4]10.value=10.left.value
[5]10.left=10.left.left
[6]10.right=newNode
```

<img src="img\微信截图_20200722182648.png" alt="微信截图_20200722182648" style="zoom:80%;" />

【3】双旋转

```java
当符合右旋转的条件时，即10的左子树的高度-10的右子树的高度>1
[1]如果7的右子树的高度>7的左子树的高度，需要对7进行左旋转
[2]之后再对10进行右旋转
    
当符合左旋转的条件时，即10的右子树的高度-10的左子树的高度>1
[1]如果7的左子树的高度>7的右子树的高度，需要对7进行右旋转
[2]之后再对10进行左旋转
```

<img src="img\微信截图_20200722183831.png" alt="微信截图_20200722183831" style="zoom:50%;" />

## 4、B树

### （1）概念

允许每个节点可以有更多的数据项和更多的子节点，就是多叉树

如图B树通过重新组织节点， 降低了树的高度

文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k)，这样每个节点只需要一次I/O就可以完全载入

### （2）2-3树

2-3树是最简单的B树结构, 2-3树是由二节点和三节点构成的树。具有如下特点:
2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件)
有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.
有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点.

当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面3个条件

<img src="img\微信截图_20200722223234.png" alt="微信截图_20200722223234" style="zoom:80%;" />

### （3）2-3-4树

![微信截图_20200722223336](img\微信截图_20200722223336.png)

### （4）B树、B+树和B*树

#### 【1】B树

B-tree树即B树，B即Balanced，平衡的意思。有人把B-tree翻译成B-树，容易让人产生误解。会以为B-树是一种树，而B树又是另一种树。实际上，B-tree就是指的B树。

```
B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4
B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点

关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据.
搜索有可能在非叶子结点结束
其搜索性能等价于在关键字全集内做一次二分查找
```

<img src="img\微信截图_20200722230203.png" alt="微信截图_20200722230203" style="zoom:50%;" />



#### 【2】B+树

B+树是B树的变体，也是一种多路搜索树。

```
B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找
所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。
不可能在非叶子结点命中
非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层
更适合文件索引系统
B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然.

```



<img src="img\微信截图_20200722230307.png" alt="微信截图_20200722230307" style="zoom:50%;" />

#### 【3】B*树

B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。

```
B*树定义了非叶子结点关键字个数至少为(2/3)*M，其中M是度，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2。

从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高

```



<img src="img\微信截图_20200722230409.png" alt="微信截图_20200722230409" style="zoom:50%;" />



## 5、图

### （1）表示方式

#### 【1】邻接矩阵

邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1....n个点。



无向图：

![微信截图_20200723163640](img\微信截图_20200723163640.png)



有向图

<img src="img\微信截图_20200724095537.png" alt="微信截图_20200724095537" style="zoom:80%;" />

代码：

```
[1]ArrayList存储顶点
[2]int[][]保存邻接矩阵
```

#### 【2】邻接表

邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成

无向图：

![微信截图_20200723163745](img\微信截图_20200723163745.png)



![微信截图_20200724095934](img\微信截图_20200724095934.png)



有向图

![微信截图_20200724100758](img\微信截图_20200724100758.png)



代码

```
[1]ArrayList保存顶点
[2]链表保存边
```



### （2）遍历

#### 【1】DFS

深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。



![微信截图_20200724172011](img\微信截图_20200724172011.png)



邻接矩阵：O(n^2)

邻接表：O(n+e)， e：边的数量

#### 【2】BFS

![搜狗截图20年07月26日2030_1](img\搜狗截图20年07月26日2030_1.png)

邻接矩阵：O(n^2)

邻接表：O(n+e)， e：边的数量

# 四、算法

## 1、递归

递归就是方法自己调用自己,每次调用时**传入不同的变量**.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁

### （1）应用场景

各种数学问题如: 8皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题(回溯), 球和篮子的问题(google编程大赛)
各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.
将用栈解决的问题-->第归代码比较简洁

### （2）递归需要遵守的重要规则

1）执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
2）方法的局部变量是独立的，不会相互影响, 比如n变量
3）如果方法中使用的是**引用类型变量**(比如**数组**)，就会共享该引用类型的数据.
4）递归**必须向退出递归的条件逼近**，否则就是无限递归,出现StackOverflowError，死龟了:)
5）当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。

### （3）经典面试题

#### 【1】迷宫

#### 【2】8皇后

1）第一个皇后先放第一行第一列
2）第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适
3）继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解
4）**当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到**.
5）然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤

说明：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个**一维数组**即可解决问题. arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} ，arr[i] = val , 表示第i+1个皇后，放在第i+1行的第val+1列

第1个皇后放在第1行的第1列
第2个皇后放在第2行的第5列
第3个皇后放在第3行的第8列
第4个皇后放在第4行的第6列
第5个皇后放在第5行的第3列
第6个皇后放在第6行的第7列
第7个皇后放在第7行的第2列
第8个皇后放在第8行的第4列



## 2、排序

### （1）种类

<img src="img\微信截图_20200526111639.png" alt="微信截图_20200526111639" style="zoom:80%;" />



### （2）时间复杂度和空间复杂度

【1】时间频度：一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)

【2】时间复杂度：T(n)=Ｏ( f(n) )

Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n) <O(n!)



O(log2n)

![图片1](img\图片1.png)



在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2n)  。 O(log2n) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log3n) 

【3】空间复杂度：缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间.

### （3）排序算法的时间复杂度

![图片2](img\图片2.png)





稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；
内排序：所有排序操作都在内存中完成；
外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；

时间复杂度： 一个算法执行所耗费的时间。
空间复杂度：运行完一个程序所需内存的大小。
n: 数据规模
k: “桶”的个数
In-place:    不占用额外内存
Out-place: 占用额外内存



![图片6](img\图片6.png)

### （4）冒泡排序

冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次**比较**
**相邻元素**的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒



因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来**没有进行过交换，就说明序列有序**，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较

### （5）选择排序

第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，

第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，

第三次从arr[2]~arr[n-1]中选取最小值，与arr[2]交换，

第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，

第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，

总共通过n-1次，得到一个按排序码从小到大排列的有序序列。

**先遍历搜索找到最小值，与arr[i]交换**

### （6）插入排序



![图片7](H:/mycode4test/AlgorithmNew/img/图片7.png)

### （7）希尔排序

希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。

<img src="H:/mycode4test/AlgorithmNew/img/图片8.png" alt="图片8" style="zoom:70%;" />

希尔排序时， 对有序序列在插入时采用交换法（冒泡）, 
希尔排序时， 对有序序列在插入时采用移动法（插入）,



### （8）快速排序 

快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列



<img src="img/图片9.png" alt="图片9" style="zoom:80%;" />





一轮排序的过程

<img src="img\5644137-43b34643d2531ef1.jpg" alt="5644137-43b34643d2531ef1" style="zoom:80%;" />

### （9）归并排序

该算法采用经典的**分治**（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。

<img src="img\图片3.png" alt="图片3" style="zoom:70%;" />

**归并排序可以采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程。**



<img src="img\图片4.png" alt="图片4" style="zoom:70%;" />



<img src="img\图片5.png" alt="图片5" style="zoom:67%;" />



```
left=0,mid=3,right=7
left=0,mid=1,right=3
left=0,mid=0,right=1
merge:left=0,mid=0,right=1
===============
left=2,mid=2,right=3
merge:left=2,mid=2,right=3
===============
merge:left=0,mid=1,right=3
===============
left=4,mid=5,right=7
left=4,mid=4,right=5
merge:left=4,mid=4,right=5
===============
left=6,mid=6,right=7
merge:left=6,mid=6,right=7
===============
merge:left=4,mid=5,right=7
===============
merge:left=0,mid=3,right=7
===============
```



### （10）基数排序

基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用

基数排序(Radix Sort)是桶排序的扩展



用空间换时间，容易内存溢出



## 3、查询搜索算法

1) 顺序(线性)查找
2) 二分查找/折半查找
3) 插值查找
4) 斐波那契查找（黄金分割点查找）

### （1）二分查找

有序数组

### （2）插值插值

```
插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找。
将折半查找中的求mid 索引的公式 , low 表示左边索引left, high表示右边索引right.key 就是前面我们讲的  findVal

int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low])  ;/*插值索引*/
对应前面的代码公式：int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])
```



![QQ截图20200531204400](img\QQ截图20200531204400.png)

对于数据量较大，关键字**分布比较均匀**的查找表来说，采用插值查找, 速度较快.
关键字分布不均匀的情况下，该方法不一定比折半查找要好

### （3）斐波那契查找

黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意向不大的效果。
斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值0.618

斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即mid=low+F(k-1)-1（F代表斐波那契数列），如下图所示



![图片10](img\图片10.png)



由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明：只要顺序表的长度为F[k]-1，则可以将该表分成长度为F[k-1]-1和F[k-2]-1的两段，即如上图所示。从而中间位置为mid=low+F(k-1)-1           

类似的，每一子段也可以用相同的方式分割
但顺序表长度n不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n增加至F[k]-1。这里的k值只要能使得F[k]-1恰好大于或等于n即可，由以下代码得到,顺序表长度增加后，新增的位置（从n+1到F[k]-1位置），都赋为n位置的值即可。

while(n>fib(k)-1)
    k++;



## 4、位运算

### （1）概念

字节：存储数据的单位用字节表示，8位无符号数（bit）代表1个字节（byte）

字符：不同编码里，字符和字节的对应关系不同

**①**ASCII码中，一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。

**②**UTF-8编码中，一个英文字符等于一个字节，一个中文（含繁体）等于三个字节。

**③**Unicode编码中，一个英文等于两个字节，一个中文（含繁体）等于两个字节。

符号：英文标点占一个字节，中文标点占两个字节。

### （2）进制转换

2进制转8进制：从右往左，每3位为1组，不够的左边补0

2进制转16进制：从右往左，每4位为1组，不够的左边补0



```java
//二进制
int a=0b110;
//八进制
int b=0110;
//十六进制
int c=0x110;
二进制表示0b
八进制表示0
十六进制表示0x
```

十进制转二进制：数字除以2直到商为0，得到的结果倒序就是对应的2进制

### （3）原码、反码、补码、有符号数

有符号数：计算机内都是采用补码保存有符号数

原码：最高位是符号为，0代表正，1代表负，其余代表数字大小

反码：正数的反码与原码相同，负数的反码是符号位不变，其余位取反

补码：正数的补码与原码相同，负数的补码是反码+1

Byte类：-128~127 -2^7~2^7-1

Integer类：-2^31~2^31-1

Long类：-2^63~2^63-1

### （4）位运算

```java
public static void main(String[] args) {
	     int a = 60; /* 60 = 0011 1100 */ 
	     int b = 13; /* 13 = 0000 1101 */
	     int c = 0;
	     c = a & b;       /* 12 = 0000 1100 */
	     System.out.println("a & b = " + c );
	 
	     c = a | b;       /* 61 = 0011 1101 */
	     System.out.println("a | b = " + c );
	 	//异或 同为0，异为1
	     c = a ^ b;       /* 49 = 0011 0001 */
	     System.out.println("a ^ b = " + c );
	 	//非
	     c = ~a;          /*-61 = 1100 0011 */
	     System.out.println("~a = " + c );
	 
	     c = a << 2;     /* 240 = 1111 0000 */
	     System.out.println("a << 2 = " + c );
	 
	     c = a >> 2;     /* 15 = 1111 */
	     System.out.println("a >> 2  = " + c );
	  
	     c = a >>> 2;     /* 15 = 0000 1111 */
	     System.out.println("a >>> 2 = " + c );
	  }

```

## 5、分治法

（1）概念

分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……
分治算法可以求解的一些经典问题
二分搜索
大整数乘法
棋盘覆盖
合并排序
快速排序
线性时间选择
最接近点对问题
循环赛日程表
汉诺塔

（2）步骤

分治法在每一层递归上都有三个步骤：
分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题
解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题
合并：将各个子问题的解合并为原问题的解。

```
if |P|≤n0
   then return(ADHOC(P))
//将P分解为较小的子问题 P1 ,P2 ,…,Pk
for i←1 to k
do yi ← Divide-and-Conquer(Pi)   递归解决Pi
T ← MERGE(y1,y2,…,yk)   合并子问题
return(T)

```

其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。

（3）汉诺塔

```
[1]如果是有一个盘， A->C

[2]如果我们有 n >= 2 情况，我们总是可以看做是两个盘 1.最下边的盘 2. 上面的盘

先把 最上面的盘 A->B
把最下边的盘 A->C
把B塔的所有盘 从 B->C   

```

## 6、动态规划

动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法

动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。

与分治法不同的是，**适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的**。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )

动态规划可以通过**填表（二维数组）**的方式来逐步推进，得到最优解.

（1）背包

背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。

【1】0-1背包

要求装入的物品不能重复

解决思路：

```
每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。
即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。
再令v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值。也就是i、j、v[i][j]都有意义

(1) v[i][0]=v[0][j]=0; //表示 填入表 第一行和第一列是0，即v[i][0]代表背包里有i个物品，0个空间；v[0][j]代表背包里没有物品，有j的空间；所以数组的下标和物品以及重量的下标正好错开了0

(2) 当w[i]> j 时：v[i][j]=v[i-1][j]   // 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略
(3) 当j>=w[i]时： v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]}  
// 当准备加入的新增的商品的容量小于等于当前背包的容量,
// 装入的方式:
v[i-1][j]： 就是上一个单元格的装入的最大值，如果不装入i，那么v[i][j]=v[i-1][j]
v[i] : 表示当前商品的价值 
v[i-1][j-w[i]] ： 要想把第i个物品装进去，就得把背包空出空间，所以用j-w[i]，否则背包就超了j；也就是说，v[i][j]依赖v[i-1][j-w[i]]，所以是动态规划


```



![微信截图_20200727191600](img\微信截图_20200727191600.png)



```
验证公式:
v[1][1] =1500
1. i = 1, j = 1 
2. w[i] = w[1] = 1
w [1] = 1  j = 1   v[i][j]=max{v[i-1][j], v[i]+v[i-1][j-w[i]]} : 
v[1][1] = max {v[0][1], v[1] + v[0][1-1]} = max{0, 1500 + 0} = 1500
v[3][4] 
1. i = 3；j = 4
w[i] = w[3] =3 j = 4
j = 4 >= w[i] = 3 => 4 >= 3

v[3][4] = max {v[2][4], v[3] + v[2][1]} = max{3000, 2000+1500} = 2000+1500
```

【2】完全背包

每种物品都有无限件可用，无限背包可以转化为01背包

## 7、KMP

KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法
Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间
参考资料：https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html

为什么JDK中String类的indexof不使用KMP或者Boyer-Moore等时间复杂度低的算法？

原来JDK的编写者们认为大多数情况下，字符串都不长，使用原始实现可能代价更低。因为KMP和Boyer-Moore算法都需要预先计算处理来获得辅助数组，需要一定的时间和空间，这可能在短字符串查找中相比较原始实现耗费更大的代价。而且一般大字符串查找时，程序员们也会使用其它特定的数据结构，查找起来更简单。这有点类似于排除特定情况下的快速排序了。不同环境选择不同算法。

### （1）next数组

**字符串的前缀**： 从下标0开始的一段连续的子串。”aba” 是”abaca”的一个前缀（prefix）。我们用prefix(i) 表示字符串中0~i这个前缀。

**字符串的后缀**：从任意下标开始到字符串结尾的一段连续子串。”aca“是“abaca”的一个后缀（suffix）。我们用suffix(i) 表示字符串中i~n-1 这段后缀。

**两个串的最长公共前缀**：两个串的前缀中相等且最长的一组前缀。“aba”是“abacc”和“ababb”的最长公共前缀。

【1】部分匹配值表

![QQ截图20200802144244](img\QQ截图20200802144244.png)



![QQ截图20200802144436](img\QQ截图20200802144436.png)



**其实就是把子串B当成主串，子串A当成模式串，发现子串B的‘C’不匹配，就把子串A取next[b]的值，和kmp中赋值的部分匹配表一样**

**把A当成主串，B是模式串也可以，但是此时子串B的部分匹配表就不是12345了，因为他已经失去了前边的字符串，他的部分匹配表就变成了子串A的部分匹配表00012**

### （2）kmp

![搜狗截图20年08月01日2116_2](img\搜狗截图20年08月01日2116_2.png)



![搜狗截图20年08月01日2117_3](img\搜狗截图20年08月01日2117_3.png)



## 8、贪心算法

贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法

贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果



```
假设存在下面需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号

遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系） 
将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。
重复第1步直到覆盖了全部的地区
```

![微信截图_20200803170534](img\微信截图_20200803170534.png)



## 9、最小生成树MST

给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树 
N个顶点，一定有N-1条边;包含全部顶点;N-1条边都在图中



![微信截图_20200808190304](img\微信截图_20200808190304.png)



有7个村庄(A, B, C, D, E, F, G) ，现在需要修路把7个村庄连通
各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里
问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短?
思路: 尽可能的选择少的路线，并且每条路线最小，保证总里程数最少.



### （1）普里姆算法（贪心）对点操作

【1】设G=(V,E)是连通网，T=(U,D)是最小生成树，V,U是顶点集合，E,D是边的集合 
【2】若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的visited[u]=1
【3】若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui,vj）加入集合D中，标记visited[vj]=1
【4】重复步骤【2】，直到U与V相等，即所有顶点都被标记为访问过



```
1.从<A>顶点开始处理  ======> <A,G> 2
A-C [7] A-G[2] A-B[5] => 

2. <A,G> 开始 , 将A 和 G 顶点和他们相邻的还没有访问的顶点进行处理 =》<A,G,B>
A-C[7] A-B[5]  G-B[3] G-E[4] G-F[6]

3. <A,G,B> 开始，将A,G,B 顶点 和他们相邻的还没有访问的顶点进行处理=><A,G,B,E>
A-C[7] G-E[4] G-F[6] B-D[9] 
.....
4.{A,G,B,E}->F//第4次大循环 ，  对应 边<E,F> 权值：5
5.{A,G,B,E,F}->D//第5次大循环 ， 对应 边<F,D> 权值：4
6. {A,G,B,E,F,D}->C//第6次大循环 ， 对应 边<A,C> 权值：7 ===> <A,G,B,E,F,D,C>

```



### （2）克鲁斯卡尔算法（对边操作）

基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路
具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止



![QQ截图20200808230456](img\QQ截图20200808230456.png)

**不能按照节点是否访问过来判断有回路，否则，在连接了FE和CD两条边后，实际上DE已经都访问过了，如果按照这种情况，DE都这条边都无法连上**

```
克鲁斯卡尔算法重点需要解决的以下两个问题： 
问题一:对图的所有边按照权值大小进行排序。 
问题二:将边添加到最小生成树中时，怎么样判断是否形成了回路。

问题一很好解决，采用排序算法进行排序即可。

问题二，处理方式是：记录顶点在"最小生成树"中的终点，顶点的终点是"在最小生成树中与它连通的最大顶点"(*关于这一点，后面会通过图片给出说明*)。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。 以下图来进行说明：

在将<E,F> <C,D> <D,E>加入到最小生成树R中之后，这几条边的顶点就都有了终点：

C的终点是F。 
D的终点是F。 
E的终点是F。 
F的终点是F

关于终点，就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是"与它连通的最大顶点"。 因此，接下来，虽然<C,E>是权值最小的边。但是C和E的重点都是F，即它们的终点相同，因此，将<C,E>加入最小生成树的话，会形成回路。这就是判断回路的方式。
```

## 10、最短路径

### （1）迪杰斯特拉(Dijkstra)

### （2）弗洛伊德(Floyd)

## 11、马踏棋盘算法

## 12、并查集

若某个家族人员过于庞大，要判断两个是否是亲戚，确实不容易，给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。