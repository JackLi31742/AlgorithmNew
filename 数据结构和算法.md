# 一、线性结构和非线性结构

1、线性：数组和链表，包括数组、队列、栈、链表

2、非线性：二维数据，多维数组，广义表，图，数

# 二、线性

## 1、稀疏数组

（1）实际问题：棋盘、地图等

<img src="img\QQ截图20200516180620.png" alt="QQ截图20200516180620" style="zoom:80%;" />

（2）解决

稀疏数组的处理方法是:
【1】记录数组一共有几行几列，有多少个不同的值
【2】把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

【3】二维数组 转 稀疏数组的思路
1. 遍历  原始的二维数组，得到有效数据的个数 sum
2. 根据sum 就可以创建 稀疏数组 sparseArr   int[sum + 1] [3]
3. 将二维数组的有效数据数据存入到 稀疏数组

稀疏数组转原始的二维数组的思路

1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]

2.在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.

<img src="img\QQ截图20200516180823.png" alt="QQ截图20200516180823" style="zoom:80%;" />

## 2、队列（queue）

数组、链表都可以实现

### （1） 顺序队列（数组）

因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front及 rear分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变

【1】构造器

front=-1，指向队列头部，是队列第一个数据的前一个位置

rear=-1，指向队列尾部，是最后一个数据的位置

【2】队满

rear  == maxSize - 1

【3】队空

front==rear

【4】入队

将尾指针往后移：rear++

【5】出队（获取数据）

front++

【6】peek

arr[front+1]

### （2）环形队列（数组）

1. front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素， 
   front 的初始值 = 0

2. rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定，
   rear 的初始值 = 0

3. 当队列满时，条件是  (rear  + 1) % maxSize == front 【满】

   tail=3，head=4，n=8，所以总结一下规律就是：(3+1)%8=4。多画几张队满的图，你就会发现，当队满时，(tail+1)%n=head。你有没有发现，当队列满时，图中的 tail 指向的位置实际上是没有存储数据的。所以，**循环队列会浪费一个数组的存储空间**

4.  对队列为空的条件， rear == front 空

5. 当我们这样分析， 队列中有效的数据的个数   (rear + maxSize - front) % maxSize   // rear = 1 front = 0 

6. 我们就可以在原来的队列上修改得到，一个环形队列

【1】入队

rear=(rear+1)%maxSize

【2】出队

```java
// 1. 先把 front 对应的值保留到一个临时变量
// 2. 将 front 后移, 考虑取模
// 3. 将临时保存的变量返回
int value = arr[front];
front = (front + 1) % maxSize;
```

【3】peek

arr[front]

【4】遍历

```java
for (int i = front; i < front + size() ; i++) {
			System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
}
```

<img src="img\3d81a44f8c42b3ceee55605f9aeedcec.jpg" alt="3d81a44f8c42b3ceee55605f9aeedcec" style="zoom:60%;" />





## 3、单链表（Linked List）

### （1）物理结构

![QQ截图20200516215648](img\QQ截图20200516215648.png)



### （2）增删改查

#### 【1】顺序插入（尾插）

```java
	private HeroNode head = new HeroNode(0, "", "");
	
	
	//返回头节点
	public HeroNode getHead() {
		return head;
	}

	//添加节点到单向链表
	//思路，当不考虑编号顺序时
	//1. 找到当前链表的最后节点
	//2. 将最后这个节点的next 指向 新的节点
	public void add(HeroNode heroNode) {
		
		//因为head节点不能动，因此我们需要一个辅助遍历 temp
		HeroNode temp = head;
		//遍历链表，找到最后
		while(temp.next!=null) {
			
			//如果没有找到最后, 将将temp后移
			temp = temp.next;
		}
		//当退出while循环时，temp就指向了链表的最后
		//将最后这个节点的next 指向 新的节点
		temp.next = heroNode;
	}
```

#### 【2】先查询后插入，查找到合适的之后再插入

1. 首先找到新添加的节点的位置, 是通过辅助变量(指针), 通过遍历来搞定
2. 新的节点.next = temp.next

3. 将temp.next = 新的节点

```java
public void addByOrder(HeroNode heroNode) {
		//因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置
		//因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了
		HeroNode temp = head;
		boolean flag = false; // flag标志添加的编号是否存在，默认为false
		while(temp.next != null) {
			
			if(temp.next.no > heroNode.no) { //位置找到，就在temp的后面插入
				break;
			} else if (temp.next.no == heroNode.no) {//说明希望添加的heroNode的编号已然存在
				
				flag = true; //说明编号存在
				break;
			}
			temp = temp.next; //后移，遍历当前链表
		}
		//判断flag 的值
		if(flag) { //不能添加，说明编号存在
			System.out.printf("准备插入的英雄的编号 %d 已经存在了, 不能加入\n", heroNode.no);
		} else {
			//插入到链表中, temp的后面
			heroNode.next = temp.next;
			temp.next = heroNode;
		}
	}
```



#### 【3】修改

**设置flag的思想很不错**，如果不设置flag，就需要在while循环中的temp.no == newHeroNode.no进行修改

```java
//1. 根据 newHeroNode 的 no 来修改即可
	public void update(HeroNode newHeroNode) {
		//判断是否空
		if(head.next == null) {
			System.out.println("链表为空~");
			return;
		}
		//找到需要修改的节点, 根据no编号
		//定义一个辅助变量
		HeroNode temp = head.next;
		boolean flag = false; //表示是否找到该节点
		while(true) {
			if (temp == null) {
				break; //已经遍历完链表
			}
			if(temp.no == newHeroNode.no) {
				//找到
				flag = true;
				break;
			}
			temp = temp.next;
		}
		//根据flag 判断是否找到要修改的节点
		if(flag) {
			temp.name = newHeroNode.name;
			temp.nickname = newHeroNode.nickname;
		} else { //没有找到
			System.out.printf("没有找到 编号 %d 的节点，不能修改\n", newHeroNode.no);
		}
	}
```

#### 【4】删除

temp.next = temp.next.next;

### （3）常见面试题

## 4、双链表

### （1）增删改查

#### 【1】遍历 

和 单链表一样，只是可以向前，也可以向后查找

#### 【2】添加 

(默认添加到双向链表的最后)
(1) 先找到双向链表的最后这个节点

```java
 temp.next = newHeroNode
 newHeroNode.pre = temp;
```



#### 【3】先查询再插入

```java
heroNode.next = temp.next;
temp.next.pre=heroNode;
temp.next = heroNode;
heroNode.pre=temp
```



#### 【4】修改 

思路和 原来的单向链表一样.

#### 【5】删除

(1) 因为是双向链表，因此，我们可以实现自我删除某个节点
(2) 直接找到要删除的这个节点，比如temp
	

```java
			//如果删除的是头结点，头结点的pre是null
			if(temp!=head){
                temp.pre.next = temp.next;
            }
			
			// 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针
			if (temp.next != null) {
				temp.next.pre = temp.pre;
			}
```



## 5、环形链表(约瑟夫环)

## 6、栈

### （1）应用场景

表达式求值

子程序调用

二叉树的遍历

DFS

### （2）数组和链表实现

1. 使用数组来模拟栈
2. 定义一个 top  来表示栈顶，初始化 为  -1
3. 入栈的操作，当有数据加入到栈时， top++;  stack[top] = data;
4. 出栈的操作， int value = stack[top]; top--, return value

### （3）前缀、中缀、后缀表达式

#### 【1】前缀表达式(波兰表达式)

 (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6

#### 【2】中缀

常见的运算表达式，如(3+4)×5-6，一般转成后缀表达式

#### 【3】后缀（逆波兰表达式）

(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –

### （4）常见面试题

#### 【1】基本计算器

1. 通过一个 index  值（索引），来遍历我们的表达式
2. 如果我们发现是一个数字, 就直接入数栈
3. 如果发现扫描到是一个符号,  就分如下情况
3.1 如果发现当前的符号栈为 空，就直接入栈
3.2 如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符， 就需要从数栈中pop出两个数,在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈， 如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.
4. 当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行.

5. 最后在数栈只有一个数字，就是表达式的结果

#### 【2】中缀转后缀

1) 初始化两个栈：**运算符栈s1和储存中间结果的栈s2**；
2) 从左至右扫描中缀表达式；
3) 遇到操作数时，将其压s2；
4) 遇到运算符时，比较其与s1栈顶运算符的优先级：
1.如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
2.否则，若优先级比栈顶运算符的高，也将运算符压入s1；
3.否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；
5) 遇到括号时：(1) 如果是左括号“(”，则直接压入s1(2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
6) 重复步骤2至5，直到表达式的最右边
7) 将s1中剩余的运算符依次弹出并压入s2
8)  依次弹出s2中的元素并输出，**结果的逆序即为中缀表达式对应的后缀表达式**

#### 【3】后缀表达式求值

从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果

## 7、递归

递归就是方法自己调用自己,每次调用时**传入不同的变量**.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁

### （1）应用场景

各种数学问题如: 8皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题(回溯), 球和篮子的问题(google编程大赛)
各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.
将用栈解决的问题-->第归代码比较简洁

### （2）递归需要遵守的重要规则

1）执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
2）方法的局部变量是独立的，不会相互影响, 比如n变量
3）如果方法中使用的是**引用类型变量**(比如**数组**)，就会共享该引用类型的数据.
4）递归**必须向退出递归的条件逼近**，否则就是无限递归,出现StackOverflowError，死龟了:)
5）当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。

### （3）经典面试题

#### 【1】迷宫

#### 【2】8皇后

1）第一个皇后先放第一行第一列
2）第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适
3）继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解
4）**当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到**.
5）然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤

说明：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个**一维数组**即可解决问题. arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} ，arr[i] = val , 表示第i+1个皇后，放在第i+1行的第val+1列

第1个皇后放在第1行的第1列
第2个皇后放在第2行的第5列
第3个皇后放在第3行的第8列
第4个皇后放在第4行的第6列
第5个皇后放在第5行的第3列
第6个皇后放在第6行的第7列
第7个皇后放在第7行的第2列
第8个皇后放在第8行的第4列





