# 一、线性结构和非线性结构

1、线性：数组和链表，包括数组、队列、栈、链表

2、非线性：二维数据，多维数组，广义表，图，数

# 二、线性

## 1、稀疏数组

（1）实际问题：棋盘、地图等

<img src="E:\mycode\Algorithm\img\QQ截图20200516180620.png" alt="QQ截图20200516180620" style="zoom:80%;" />

（2）解决

稀疏数组的处理方法是:
【1】记录数组一共有几行几列，有多少个不同的值
【2】把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

【3】二维数组 转 稀疏数组的思路
1. 遍历  原始的二维数组，得到有效数据的个数 sum
2. 根据sum 就可以创建 稀疏数组 sparseArr   int[sum + 1] [3]
3. 将二维数组的有效数据数据存入到 稀疏数组

稀疏数组转原始的二维数组的思路

1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]

2.在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.

<img src="E:\mycode\Algorithm\img\QQ截图20200516180823.png" alt="QQ截图20200516180823" style="zoom:80%;" />

## 2、队列（queue）

数组、链表都可以实现

### （1） 顺序队列（数组）

因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front及 rear分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变

【1】构造器

front=-1，指向队列头部，是队列第一个数据的前一个位置

rear=-1，指向队列尾部，是最后一个数据的位置

【2】队满

rear  == maxSize - 1

【3】队空

front==rear

【4】入队

将尾指针往后移：rear++

【5】出队（获取数据）

front++

【6】peek

arr[front+1]

### （2）环形队列（数组）

1. front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素， 
   front 的初始值 = 0

2. rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定，
   rear 的初始值 = 0

3. 当队列满时，条件是  (rear  + 1) % maxSize == front 【满】

   tail=3，head=4，n=8，所以总结一下规律就是：(3+1)%8=4。多画几张队满的图，你就会发现，当队满时，(tail+1)%n=head。你有没有发现，当队列满时，图中的 tail 指向的位置实际上是没有存储数据的。所以，**循环队列会浪费一个数组的存储空间**

4.  对队列为空的条件， rear == front 空

5. 当我们这样分析， 队列中有效的数据的个数   (rear + maxSize - front) % maxSize   // rear = 1 front = 0 

6. 我们就可以在原来的队列上修改得到，一个环形队列

【1】入队

rear=(rear+1)%maxSize

【2】出队

```java
// 1. 先把 front 对应的值保留到一个临时变量
// 2. 将 front 后移, 考虑取模
// 3. 将临时保存的变量返回
int value = arr[front];
front = (front + 1) % maxSize;
```

【3】peek

arr[front]

【4】遍历

```java
for (int i = front; i < front + size() ; i++) {
			System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
}
```

<img src="E:\mycode\Algorithm\img\3d81a44f8c42b3ceee55605f9aeedcec.jpg" alt="3d81a44f8c42b3ceee55605f9aeedcec" style="zoom:60%;" />





## 3、单链表（Linked List）

### （1）物理结构

![QQ截图20200516215648](E:\mycode\Algorithm\img\QQ截图20200516215648.png)



### （2）增删改查

#### 【1】顺序插入（尾插）

```java
	private HeroNode head = new HeroNode(0, "", "");
	
	
	//返回头节点
	public HeroNode getHead() {
		return head;
	}

	//添加节点到单向链表
	//思路，当不考虑编号顺序时
	//1. 找到当前链表的最后节点
	//2. 将最后这个节点的next 指向 新的节点
	public void add(HeroNode heroNode) {
		
		//因为head节点不能动，因此我们需要一个辅助遍历 temp
		HeroNode temp = head;
		//遍历链表，找到最后
		while(temp.next!=null) {
			
			//如果没有找到最后, 将将temp后移
			temp = temp.next;
		}
		//当退出while循环时，temp就指向了链表的最后
		//将最后这个节点的next 指向 新的节点
		temp.next = heroNode;
	}
```

#### 【2】先查询后插入，查找到合适的之后再插入

1. 首先找到新添加的节点的位置, 是通过辅助变量(指针), 通过遍历来搞定
2. 新的节点.next = temp.next

3. 将temp.next = 新的节点

```java
public void addByOrder(HeroNode heroNode) {
		//因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置
		//因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了
		HeroNode temp = head;
		boolean flag = false; // flag标志添加的编号是否存在，默认为false
		while(temp.next != null) {
			
			if(temp.next.no > heroNode.no) { //位置找到，就在temp的后面插入
				break;
			} else if (temp.next.no == heroNode.no) {//说明希望添加的heroNode的编号已然存在
				
				flag = true; //说明编号存在
				break;
			}
			temp = temp.next; //后移，遍历当前链表
		}
		//判断flag 的值
		if(flag) { //不能添加，说明编号存在
			System.out.printf("准备插入的英雄的编号 %d 已经存在了, 不能加入\n", heroNode.no);
		} else {
			//插入到链表中, temp的后面
			heroNode.next = temp.next;
			temp.next = heroNode;
		}
	}
```



#### 【3】修改

**设置flag的思想很不错**，如果不设置flag，就需要在while循环中的temp.no == newHeroNode.no进行修改

```java
//1. 根据 newHeroNode 的 no 来修改即可
	public void update(HeroNode newHeroNode) {
		//判断是否空
		if(head.next == null) {
			System.out.println("链表为空~");
			return;
		}
		//找到需要修改的节点, 根据no编号
		//定义一个辅助变量
		HeroNode temp = head.next;
		boolean flag = false; //表示是否找到该节点
		while(true) {
			if (temp == null) {
				break; //已经遍历完链表
			}
			if(temp.no == newHeroNode.no) {
				//找到
				flag = true;
				break;
			}
			temp = temp.next;
		}
		//根据flag 判断是否找到要修改的节点
		if(flag) {
			temp.name = newHeroNode.name;
			temp.nickname = newHeroNode.nickname;
		} else { //没有找到
			System.out.printf("没有找到 编号 %d 的节点，不能修改\n", newHeroNode.no);
		}
	}
```

#### 【4】删除

temp.next = temp.next.next;

### （3）常见面试题

## 4、双链表

### （1）增删改查

#### 【1】遍历 

和 单链表一样，只是可以向前，也可以向后查找

#### 【2】添加 

(默认添加到双向链表的最后)
(1) 先找到双向链表的最后这个节点

```java
 temp.next = newHeroNode
 newHeroNode.pre = temp;
```



#### 【3】先查询再插入

```java
heroNode.next = temp.next;
temp.next.pre=heroNode;
temp.next = heroNode;
heroNode.pre=temp
```



#### 【4】修改 

思路和 原来的单向链表一样.

#### 【5】删除

(1) 因为是双向链表，因此，我们可以实现自我删除某个节点
(2) 直接找到要删除的这个节点，比如temp
	

```java
			//如果删除的是头结点，头结点的pre是null
			if(temp!=head){
                temp.pre.next = temp.next;
            }
			
			// 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针
			if (temp.next != null) {
				temp.next.pre = temp.pre;
			}
```



## 5、环形链表