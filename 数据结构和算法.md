# 一、线性结构和非线性结构

1、线性：数组和链表，包括数组、队列、栈、链表

2、非线性：二维数据，多维数组，广义表，图，树

# 二、线性

## 1、稀疏数组

（1）实际问题：棋盘、地图等

<img src="img\QQ截图20200516180620.png" alt="QQ截图20200516180620" style="zoom:80%;" />

（2）解决

稀疏数组的处理方法是:
【1】记录数组一共有几行几列，有多少个不同的值
【2】把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

【3】二维数组 转 稀疏数组的思路
1. ```
   1. 遍历  原始的二维数组，得到有效数据的个数 sum
   2. 根据sum 就可以创建 稀疏数组 sparseArr   int[sum + 1][3]
   3. 将二维数组的有效数据数据存入到 稀疏数组
   ```

   

稀疏数组转原始的二维数组的思路

```
1.先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]

2.在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.
```

<img src="img\QQ截图20200516180823.png" alt="QQ截图20200516180823" style="zoom:80%;" />

## 2、队列（queue）

数组、链表都可以实现

### （1） 顺序队列（数组）

因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front及 rear分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变

【1】构造器

front=-1，指向队列头部，是队列第一个数据的前一个位置

rear=-1，指向队列尾部，是最后一个数据的位置

【2】队满

rear  == maxSize - 1

【3】队空

front==rear

【4】入队

将尾指针往后移：rear++

【5】出队（获取数据）

front++

【6】peek

arr[front+1]

### （2）环形队列（数组）

1. front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素， 
   front 的初始值 = 0

2. rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定，
   rear 的初始值 = 0

3. 当队列满时，条件是  (rear  + 1) % maxSize == front 【满】

   tail=3，head=4，n=8，所以总结一下规律就是：(3+1)%8=4。多画几张队满的图，你就会发现，当队满时，(tail+1)%n=head。你有没有发现，当队列满时，图中的 tail 指向的位置实际上是没有存储数据的。所以，**循环队列会浪费一个数组的存储空间**

4.  对队列为空的条件， rear == front 空

5. 当我们这样分析， 队列中有效的数据的个数   (rear + maxSize - front) % maxSize   // rear = 1 front = 0 

6. 我们就可以在原来的队列上修改得到，一个环形队列

【1】入队

rear=(rear+1)%maxSize

【2】出队

```java
// 1. 先把 front 对应的值保留到一个临时变量
// 2. 将 front 后移, 考虑取模
// 3. 将临时保存的变量返回
int value = arr[front];
front = (front + 1) % maxSize;
```

【3】peek

arr[front]

【4】遍历

```java
for (int i = front; i < front + size() ; i++) {
			System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
}
```

<img src="img\3d81a44f8c42b3ceee55605f9aeedcec.jpg" alt="3d81a44f8c42b3ceee55605f9aeedcec" style="zoom:60%;" />





## 3、单链表（Linked List）

### （1）物理结构

![QQ截图20200516215648](img\QQ截图20200516215648.png)



### （2）增删改查

#### 【1】顺序插入（尾插）

```java
	private HeroNode head = new HeroNode(0, "", "");
	
	
	//返回头节点
	public HeroNode getHead() {
		return head;
	}

	//添加节点到单向链表
	//思路，当不考虑编号顺序时
	//1. 找到当前链表的最后节点
	//2. 将最后这个节点的next 指向 新的节点
	public void add(HeroNode heroNode) {
		
		//因为head节点不能动，因此我们需要一个辅助遍历 temp
		HeroNode temp = head;
		//遍历链表，找到最后
		while(temp.next!=null) {
			
			//如果没有找到最后, 将将temp后移
			temp = temp.next;
		}
		//当退出while循环时，temp就指向了链表的最后
		//将最后这个节点的next 指向 新的节点
		temp.next = heroNode;
	}
```

#### 【2】先查询后插入，查找到合适的之后再插入

1. 首先找到新添加的节点的位置, 是通过辅助变量(指针), 通过遍历来搞定
2. 新的节点.next = temp.next

3. 将temp.next = 新的节点

```java
public void addByOrder(HeroNode heroNode) {
		//因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置
		//因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了
		HeroNode temp = head;
		boolean flag = false; // flag标志添加的编号是否存在，默认为false
		while(temp.next != null) {
			
			if(temp.next.no > heroNode.no) { //位置找到，就在temp的后面插入
				break;
			} else if (temp.next.no == heroNode.no) {//说明希望添加的heroNode的编号已然存在
				
				flag = true; //说明编号存在
				break;
			}
			temp = temp.next; //后移，遍历当前链表
		}
		//判断flag 的值
		if(flag) { //不能添加，说明编号存在
			System.out.printf("准备插入的英雄的编号 %d 已经存在了, 不能加入\n", heroNode.no);
		} else {
			//插入到链表中, temp的后面
			heroNode.next = temp.next;
			temp.next = heroNode;
		}
	}
```



#### 【3】修改

**设置flag的思想很不错**，如果不设置flag，就需要在while循环中的temp.no == newHeroNode.no进行修改

```java
//1. 根据 newHeroNode 的 no 来修改即可
	public void update(HeroNode newHeroNode) {
		//判断是否空
		if(head.next == null) {
			System.out.println("链表为空~");
			return;
		}
		//找到需要修改的节点, 根据no编号
		//定义一个辅助变量
		HeroNode temp = head.next;
		boolean flag = false; //表示是否找到该节点
		while(true) {
			if (temp == null) {
				break; //已经遍历完链表
			}
			if(temp.no == newHeroNode.no) {
				//找到
				flag = true;
				break;
			}
			temp = temp.next;
		}
		//根据flag 判断是否找到要修改的节点
		if(flag) {
			temp.name = newHeroNode.name;
			temp.nickname = newHeroNode.nickname;
		} else { //没有找到
			System.out.printf("没有找到 编号 %d 的节点，不能修改\n", newHeroNode.no);
		}
	}
```

#### 【4】删除

temp.next = temp.next.next;

### （3）常见面试题

## 4、双链表

### （1）增删改查

#### 【1】遍历 

和 单链表一样，只是可以向前，也可以向后查找

#### 【2】添加 

(默认添加到双向链表的最后)
(1) 先找到双向链表的最后这个节点

```java
 temp.next = newHeroNode
 newHeroNode.pre = temp;
```



#### 【3】先查询再插入

```java
heroNode.next = temp.next;
temp.next.pre=heroNode;
temp.next = heroNode;
heroNode.pre=temp
```



#### 【4】修改 

思路和 原来的单向链表一样.

#### 【5】删除

(1) 因为是双向链表，因此，我们可以实现自我删除某个节点
(2) 直接找到要删除的这个节点，比如temp
	

```java
			//如果删除的是头结点，头结点的pre是null
			if(temp!=head){
                temp.pre.next = temp.next;
            }
			
			// 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针
			if (temp.next != null) {
				temp.next.pre = temp.pre;
			}
```



## 5、环形链表(约瑟夫环)

## 6、栈

### （1）应用场景

表达式求值

子程序调用

二叉树的遍历

DFS

### （2）数组和链表实现

1. 使用数组来模拟栈
2. 定义一个 top  来表示栈顶，初始化 为  -1
3. 入栈的操作，当有数据加入到栈时， top++;  stack[top] = data;
4. 出栈的操作， int value = stack[top]; top--, return value

### （3）前缀、中缀、后缀表达式

#### 【1】前缀表达式(波兰表达式)

 (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6

#### 【2】中缀

常见的运算表达式，如(3+4)×5-6，一般转成后缀表达式

#### 【3】后缀（逆波兰表达式）

(3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –

### （4）常见面试题

#### 【1】基本计算器

1. 通过一个 index  值（索引），来遍历我们的表达式
2. 如果我们发现是一个数字, 就直接入数栈
3. 如果发现扫描到是一个符号,  就分如下情况
3.1 如果发现当前的符号栈为 空，就直接入栈
3.2 如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符， 就需要从数栈中pop出两个数,在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈， 如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.
4. 当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行.

5. 最后在数栈只有一个数字，就是表达式的结果

#### 【2】中缀转后缀

1) 初始化两个栈：**运算符栈s1和储存中间结果的栈s2**；
2) 从左至右扫描中缀表达式；
3) 遇到操作数时，将其压s2；
4) 遇到运算符时，比较其与s1栈顶运算符的优先级：
1.如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
2.否则，若优先级比栈顶运算符的高，也将运算符压入s1；
3.否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；
5) 遇到括号时：(1) 如果是左括号“(”，则直接压入s1(2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
6) 重复步骤2至5，直到表达式的最右边
7) 将s1中剩余的运算符依次弹出并压入s2
8)  依次弹出s2中的元素并输出，**结果的逆序即为中缀表达式对应的后缀表达式**

#### 【3】后缀表达式求值

从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果

## 7、哈希



![图片11](img\图片11.png)



<img src="img\微信截图_20200602102245.png" alt="微信截图_20200602102245" style="zoom:50%;" />

# 三、非线性

## 1、树

### （1）概念

如果该二叉树的所有叶子节点都在最后一层，并且结点总数= **2^n -1** , n 为层数，则我们称为**满二叉树**。
如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为**完全二叉树**。

### （2）遍历

#### 【1】递归

前序遍历（中左右）: 先输出父节点，再遍历左子树和右子树
中序遍历（左中右）: 先遍历左子树，再输出父节点，再遍历右子树
后序遍历（左右中）: 先遍历左子树，再遍历右子树，最后输出父节点

#### 【2】非递归（迭代）

需要用自定义的栈模拟递归时的系统栈，莫里斯遍历虽然空间复杂度降下来了，但是会修改整个二叉树的结构！

##### 前序遍历（中左右）

要想最终的顺序得到中左右，那么入栈的时候，就是右左中，可以简化，只放右节点

```java
		TreeNode cur = root;
		//第一次把root放进去，是为了好进第一个while循环，因为当节点走到树的右侧时，其实和左侧的套路一样
		stack.push(cur);
		while (!stack.isEmpty()) {
			TreeNode node = stack.pop();
			while (node != null) {
				result.add(node.val);
				if (node.right != null) {
					stack.push(node.right);
				}
				node = node.left;
			}
		}
```



##### 中序遍历（左中右）

每次都是节点的左节点入栈，所以当传入节点的右节点时，也要把这个节点的左边节点进行入栈

```java
while (cur != null || !stack.isEmpty()) {
			while (cur != null) {
				stack.push(cur);
				cur = cur.left;
			}
			TreeNode node = stack.pop();
			result.add(node.val);

			cur = node.right;
			while (cur != null) {
				stack.push(cur);
				cur = cur.left;
			}

		}
```

##### 后序遍历（左右中）

后序遍历要先从根节点一直找到左子树的最左边的节点，然后回退到根节点，这时，需要标注根节点flag=true，标明已经回退过一次，然后传入根节点的右子树，然后重复上述过程，如果栈里的节点的flag=true，那么标明左右子树都已经找到过

```java
TreeNode cur=root;
		
		Stack<Node> stack=new Stack<Node>();
		
		while(cur!=null||!stack.isEmpty()) {
			
			//一直找到左子树的最左边
			while (cur!=null) {
				Node node=new Node(cur, false);
				stack.push(node);
				cur=cur.left;
			}
			
			if (!stack.isEmpty()) {
				if (!stack.peek().flag) {
					cur=stack.peek().treeNode.right;
					//标明从左边的子树返回到了根节点
					stack.peek().flag=true;
					
				}else {
					result.add(stack.pop().treeNode.val);
					
				}
			}
			
			
		}
```

### （3）删除节点（普通二叉树）

如果删除的节点是叶子节点，则删除该节点
如果删除的节点是非叶子节点，则删除该子树.

### （4）顺序存储二叉树（堆）

从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，


<img src="img\微信截图_20200609131025.png" alt="微信截图_20200609131025" style="zoom:80%;" />

顺序存储二叉树的特点:

顺序二叉树通常只考虑完全二叉树
第n个元素的左子节点为  2 * n + 1 
第n个元素的右子节点为  2 * n + 2
第n个元素的父节点为  (n-1) / 2

n : 表示二叉树中的第几个元素(按0开始编号)

### （5）堆排序

堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。
堆是具有以下性质的**完全二叉树**：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : **没有要求结点的左孩子的值和右孩子的值的大小关系**。
每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆

**一般升序采用大顶堆，降序采用小顶堆** 

堆排序的基本思想是：
1.**将待排序序列构造成一个大顶堆**，**从最后的非叶子节点，依次从下到上**
2.此时，整个序列的最大值就是堆顶的根节点。
3.将其与末尾元素进行交换，此时末尾就为最大值。
4.然后将剩余n-1个元素重新构造成一个堆，而这个堆，只有根节点和第二层节点不满足大顶堆的条件，所以是从上到下进行调整，这样会得到n个元素的次大值。如此反复执行，便能得到一个有序序列了。

可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.意思是**最后的数组就是从小到大的**，**当然也可以是从大到小**

### （6）哈夫曼树

给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree), 还有的书翻译为霍夫曼树。

赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1

树的带权路径长度：树的带权路径长度规定为**所有叶子结点的带权路径长度之和**，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。

<img src="img\微信截图_20200609193130.png" alt="微信截图_20200609193130" style="zoom:60%;" />



构成赫夫曼树的步骤：
1.从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树
2.取出根节点权值最小的两颗二叉树 
3.组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和  
4.再将这颗新的二叉树，以根节点的权值大小 再次排序， 不断重复  1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树



# 四、算法

## 1、递归

递归就是方法自己调用自己,每次调用时**传入不同的变量**.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁

### （1）应用场景

各种数学问题如: 8皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题(回溯), 球和篮子的问题(google编程大赛)
各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.
将用栈解决的问题-->第归代码比较简洁

### （2）递归需要遵守的重要规则

1）执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
2）方法的局部变量是独立的，不会相互影响, 比如n变量
3）如果方法中使用的是**引用类型变量**(比如**数组**)，就会共享该引用类型的数据.
4）递归**必须向退出递归的条件逼近**，否则就是无限递归,出现StackOverflowError，死龟了:)
5）当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。

### （3）经典面试题

#### 【1】迷宫

#### 【2】8皇后

1）第一个皇后先放第一行第一列
2）第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适
3）继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解
4）**当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到**.
5）然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤

说明：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个**一维数组**即可解决问题. arr[8] = {0 , 4, 7, 5, 2, 6, 1, 3} ，arr[i] = val , 表示第i+1个皇后，放在第i+1行的第val+1列

第1个皇后放在第1行的第1列
第2个皇后放在第2行的第5列
第3个皇后放在第3行的第8列
第4个皇后放在第4行的第6列
第5个皇后放在第5行的第3列
第6个皇后放在第6行的第7列
第7个皇后放在第7行的第2列
第8个皇后放在第8行的第4列



## 2、排序

### （1）种类

<img src="img\微信截图_20200526111639.png" alt="微信截图_20200526111639" style="zoom:80%;" />



### （2）时间复杂度和空间复杂度

【1】时间频度：一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)

【2】时间复杂度：T(n)=Ｏ( f(n) )

Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n) <O(n!)



O(log2n)

![图片1](img\图片1.png)



在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2n)  。 O(log2n) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log3n) 

【3】空间复杂度：缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间.

### （3）排序算法的时间复杂度

![图片2](img\图片2.png)





稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；
内排序：所有排序操作都在内存中完成；
外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；

时间复杂度： 一个算法执行所耗费的时间。
空间复杂度：运行完一个程序所需内存的大小。
n: 数据规模
k: “桶”的个数
In-place:    不占用额外内存
Out-place: 占用额外内存



![图片6](img\图片6.png)

### （4）冒泡排序

冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次**比较**
**相邻元素**的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒



因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来**没有进行过交换，就说明序列有序**，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较

### （5）选择排序

第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，

第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，

第三次从arr[2]~arr[n-1]中选取最小值，与arr[2]交换，

第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，

第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，

总共通过n-1次，得到一个按排序码从小到大排列的有序序列。

**先遍历搜索找到最小值，与arr[i]交换**

### （6）插入排序



![图片7](H:/mycode4test/AlgorithmNew/img/图片7.png)

### （7）希尔排序

希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。

<img src="H:/mycode4test/AlgorithmNew/img/图片8.png" alt="图片8" style="zoom:70%;" />

希尔排序时， 对有序序列在插入时采用交换法（冒泡）, 
希尔排序时， 对有序序列在插入时采用移动法（插入）,



### （8）快速排序 

快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列



<img src="img/图片9.png" alt="图片9" style="zoom:80%;" />





一轮排序的过程

<img src="img\5644137-43b34643d2531ef1.jpg" alt="5644137-43b34643d2531ef1" style="zoom:80%;" />

### （9）归并排序

该算法采用经典的**分治**（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。

<img src="img\图片3.png" alt="图片3" style="zoom:70%;" />

**归并排序可以采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程。**



<img src="img\图片4.png" alt="图片4" style="zoom:70%;" />



<img src="img\图片5.png" alt="图片5" style="zoom:67%;" />



```
left=0,mid=3,right=7
left=0,mid=1,right=3
left=0,mid=0,right=1
merge:left=0,mid=0,right=1
===============
left=2,mid=2,right=3
merge:left=2,mid=2,right=3
===============
merge:left=0,mid=1,right=3
===============
left=4,mid=5,right=7
left=4,mid=4,right=5
merge:left=4,mid=4,right=5
===============
left=6,mid=6,right=7
merge:left=6,mid=6,right=7
===============
merge:left=4,mid=5,right=7
===============
merge:left=0,mid=3,right=7
===============
```



### （10）基数排序

基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用

基数排序(Radix Sort)是桶排序的扩展



用空间换时间，容易内存溢出



## 3、查询搜索算法

1) 顺序(线性)查找
2) 二分查找/折半查找
3) 插值查找
4) 斐波那契查找（黄金分割点查找）

### （1）二分查找

有序数组

### （2）插值插值

```
插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找。
将折半查找中的求mid 索引的公式 , low 表示左边索引left, high表示右边索引right.key 就是前面我们讲的  findVal

int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low])  ;/*插值索引*/
对应前面的代码公式：int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])
```



![QQ截图20200531204400](img\QQ截图20200531204400.png)

对于数据量较大，关键字**分布比较均匀**的查找表来说，采用插值查找, 速度较快.
关键字分布不均匀的情况下，该方法不一定比折半查找要好

### （3）斐波那契查找

黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意向不大的效果。
斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值0.618

斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即mid=low+F(k-1)-1（F代表斐波那契数列），如下图所示



![图片10](img\图片10.png)



由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明：只要顺序表的长度为F[k]-1，则可以将该表分成长度为F[k-1]-1和F[k-2]-1的两段，即如上图所示。从而中间位置为mid=low+F(k-1)-1           

类似的，每一子段也可以用相同的方式分割
但顺序表长度n不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n增加至F[k]-1。这里的k值只要能使得F[k]-1恰好大于或等于n即可，由以下代码得到,顺序表长度增加后，新增的位置（从n+1到F[k]-1位置），都赋为n位置的值即可。

while(n>fib(k)-1)
    k++;



a